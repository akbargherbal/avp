import { useState, useCallback, useEffect } from "react";

/**
 * Prediction Mode Hook - Algorithm-Agnostic
 *
 * Uses prediction_points from trace metadata (generated by backend).
 * Works for any algorithm that implements get_prediction_points().
 * 
 * ✅ FIX (Session: Integration Testing):
 * Added 2-second delay before advancing step to allow users to see
 * the final result visualization (e.g., TARGET_FOUND in Binary Search).
 */
export const usePredictionMode = (trace, currentStep, nextStep) => {
  const [predictionMode, setPredictionMode] = useState(true);
  const [showPrediction, setShowPrediction] = useState(false);
  const [activePrediction, setActivePrediction] = useState(null);
  const [predictionStats, setPredictionStats] = useState({
    total: 0,
    correct: 0,
  });

  // Get prediction points from trace metadata
  const predictionPoints = trace?.metadata?.prediction_points || [];

  // Auto-detect prediction points based on metadata
  useEffect(() => {
    if (!trace || !predictionMode) {
      setShowPrediction(false);
      setActivePrediction(null);
      return;
    }

    // Find prediction point matching current step
    const matchingPrediction = predictionPoints.find(
      (p) => p.step_index === currentStep
    );

    if (matchingPrediction) {
      setActivePrediction(matchingPrediction);
      setShowPrediction(true);
    } else {
      setActivePrediction(null);
      setShowPrediction(false);
    }
  }, [currentStep, trace, predictionMode, predictionPoints]);

  const handlePredictionAnswer = useCallback((userAnswer) => {
    if (!activePrediction) return;

    const isCorrect = userAnswer === activePrediction.correct_answer;

    setPredictionStats((prev) => ({
      total: prev.total + 1,
      correct: prev.correct + (isCorrect ? 1 : 0),
    }));

    setShowPrediction(false);
    setActivePrediction(null);
    
    // ✅ FIX: Check if this is the last prediction point
    const isLastPrediction = predictionPoints.length > 0 && 
      activePrediction.step_index === predictionPoints[predictionPoints.length - 1].step_index;
    
    // ✅ FIX: Add delay to show final result visualization before completion modal
    // Use longer delay (3s) for last prediction to give user time to see the outcome
    const delay = isLastPrediction ? 3000 : 2000;
    
    setTimeout(() => {
      nextStep();
    }, delay);
  }, [activePrediction, nextStep, predictionPoints]);

  const handlePredictionSkip = useCallback(() => {
    setShowPrediction(false);
    setActivePrediction(null);
    nextStep(); // Advance step after skipping (no delay needed)
  }, [nextStep]);

  const togglePredictionMode = useCallback(() => {
    setPredictionMode((prev) => !prev);
    setShowPrediction(false);
    setActivePrediction(null);
  }, []);

  const resetPredictionStats = useCallback(() => {
    setPredictionStats({ total: 0, correct: 0 });
  }, []);

  return {
    predictionMode,
    showPrediction,
    activePrediction, // New: Expose the full prediction object
    predictionStats,
    togglePredictionMode,
    handlePredictionAnswer,
    handlePredictionSkip,
    resetPredictionStats,
  };
};
